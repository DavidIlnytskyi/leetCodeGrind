/*
 https://leetcode.com/problems/delete-the-middle-node-of-a-linked-list/?envType=study-plan-v2&envId=leetcode-75
 */
class Solution {
public:
    ListNode* deleteMiddle(ListNode* head) {
        auto slow = head;
        auto fast = head;

        if(head->next != nullptr){
            fast = fast->next;
        } else {
            head = nullptr;
            return head;
        }
        while(fast->next != nullptr){
            fast = fast->next;
            if(fast->next != nullptr){
                slow = slow->next;
                fast = fast->next;
            }
        }
        slow->next = slow->next->next;
        return head;
    }
}

/*
 Main idea:

    Створити два пойнтери.

    Один буде проходити за крок одну ноду, інший дві ноди.

    Таким чином, коли швидкий пойнтер дойде до кінця, повільний
    буде на середині. Якщо ми видалимо в такій ситуації ноду,
    то ми збережемо середню ноду, і видалемо ноду після неї.

    Щоб пофіксити цю проблему ми починаємо відлік для швидкого
    пойнтера з наступної ноди. Таким чином, ми будемо змінювати
    позицію нашого повільного пойнтера тільки в тому випадку, якщо
    наш швидкий пойнтер пройшов дві позиції. Якщо швидкий пойнтер
    пройшов тільки одну ноду і зупинився, то це означає що довжина
    непарна і варто зупинитись швидше. Якщо швидший пойнтер
    пройшов дві ноди, то пойнтер може рухатись далі.

    На прикладах це
    1, 2, 3
    Швидкий пойнтер почне з 2
    Повільний з 1
    Швидкий пройде тільки один крок, тому не змінить позиції повільного
    Таким чином швидкий буде в 3, повільний в 1.
    Після закінчення алгоритму прив'язуємо next до node->next->next
    1,3

    Для
    1, 2, 3, 4
    Швидкий пойнтер почне з 2
    Повільний з 1
    Швидкий пройде два кроки, тому потрапить в 4
    Повільний лише і буде в 2
    Після закінчення алгоритму маємо видалити 4/2(2) елемент,
    Тому прив'яжемо 2 до 4
    1, 2, 4
 */