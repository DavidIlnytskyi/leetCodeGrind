/*
 https://leetcode.com/problems/house-robber/description/?envType=daily-question&envId=2024-01-21
 */
class Solution {
public:
    int rob(vector<int>& nums) {
        vector<int> dp(nums.size() + 1, 0);

        dp[1] = nums[0];
        // input: {1,2,3}
        // {0, 1, 2, 4} return dp[nums.size()]
        for(int idx = 1; idx < nums.size(); ++idx){
            dp[idx + 1] = max(dp[idx - 1] + nums[idx], dp[idx]);
        }

        return dp[nums.size()];
    }
};

/*
 Main idea:

 У цьому завданні головне обмеження полягає в тому що ми можемо
 взяти лише будинки, що не стоять поруч. Таким чином для одного
 будинка ми маємо визначити, чи ми беремо в загальну суму цей
 будинок, чи беремо його попередника.
 Для цього ми створюємо масив dp, що буде містити всі можливі
 суми з наших будинків. Для зручності(і щоб не писати додаткову
 іфку) ми робимо цей масив на 1 більшим.

 Почати варто з того, що ми додаємо в dp перший будинок. Далі ми
 дивимось що вигідніше, взяти перший будинок і скіпнути другий,
 чи взяти другий будинок і те, що було два кроки попереду. Тут
 вилазить чому варто робити розмір dp більшим на одиницю - якщо
 цього не буде, потрібно буде прописувати іфку що буде працювати
 протягом перевірки всіх елементів в масиві, але спрацьовувати
 лише один раз. Тому сума для другого будинку буде вираховуватись
 dp[1 + 1] = max(dp[1 - 1] + nums[1], dp[1])
 dp[1 + 1] = dp[idx + 1] Це робиться оскільки dp більший на одиницю
 і його перший елемент допоміжний, тому idx Буде відповідати idx + 1
 dp[1 - 1] = dp[idx - 1] Знову ж таки, idx менший за поточний елемент
 на одиницю, тому щоб потрапити в елемент, що був два кроки попереду
 залишається відняти лише одиницю.
 dp[1] = dp[idx] Якщо idx відстає на одиницю, то попередній елемент
 і буде відповідати idx.

 У кінці результатом який ми повернемо буде сума на останньому індексі
 в масиві, адже ми пройшлись по кожній будівлі, і визначили чи краще
 взяти цю будівлю(і суму будівель -2) чи суму будівлі, що була перед нею
 */