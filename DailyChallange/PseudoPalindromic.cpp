/*
 https://leetcode.com/problems/pseudo-palindromic-paths-in-a-binary-tree/?envType=daily-question&envId=2024-01-24
 */

/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int pseudoPalindromicPaths (TreeNode* root, int counter = 0) {
        if(root == nullptr){
            return 0;
        }

        counter ^= 1 <<  (root->val - 1);

        if(root->left == nullptr && root->right == nullptr ){
            return (counter & (counter - 1)) == 0 ? 1 : 0;
        }

        return pseudoPalindromicPaths(root->left, counter) + pseudoPalindromicPaths(root->right, counter);
    }
};
/*
 Main idea:

 Варто порахувати кількість паліндромів
 Для цього потрібно визначитись як визначати
 паліндром. Якщо елемент зустрічається парну
 кількість разів, то його можна розставити з
 двох сторін без проблем(1, 1, .. 2 4 2 .. 1, 1)
 Якщо елемент зустрічається непарну кількість
 разів, то його можна поставити в центр пал-
 індрому і зберегти властивість паліндрому
 Тому якщо непарних елементів більше ніж один
 ми не зможемо зберегти властивість паліндрому
 (1 2) - два непарні елементи. Тому ми будемо
 рахувати кількість непарних елементів після
 проходження всього шляху від кореня до листка

 Для цього можна юзати ерей, мапу, я спробував
 зробити за допомогою бінарних чисел.

 До прикладу нам варто додати число 3
 Всього можливих чисел у нас 9
 Наше бінарне число буде містити 1 в позиції х,
 якщо число х було присутнє непарну кількість
 разів. До прикладу, ми зустріли число 2
 1 << (2-1) <==> 10(біт на другій позиції)
 1 << (1-1) <==> 1(біт в першій позиції)
 таким чином ми можемо маркувати елемент як
 присутній. Для того щоб рахувати чи елемент
 парну кількість разів зустрівся чи ні, ми будем
 використовувати xor. До прикладу в нас вже
 зустрівся елемент на 4 позиції і зараз ми теж його
 знайшли. У нас буде щось типу
 1000 ^ (1 << (4 - 1))
 1000 ^ (1000)
 0000
 Тобто елемент буде парну кількість разів, тому ми
 не зважаємо на його входженя(можемо симетрично
 розташувати його, тому він нам не важливий)

 Як ми вже пройшли весь шлях до листка, нам залишається
 Перевірити кількість входжень 1 до нашого каунтера
 До прикладу
 У нас лише одна одиничка, що вказує на непарний елемент
 на 3 позиції  -- 100
 Якщо ця одиничка єдина, то якщо ми віднімемо від цього
 бінарного числа одиничку і порівяняємо два числа, то
 не буде жодних одиничок на тих і самих місцях
 100(compare value)

 100 - 1
 011

 (and)
 100
 011
 000
 Тобто жодна одиничка не зійшлась

 Проте якщо в нас буде кілька одиничок
 110(compare value)

 110 - 1
 101

 110
 101
 Перша одиничка зійшлась, & повернув true

 Таким чином, якщо в нас лише одна одиничка,
 тобто лише одне непарне число, ми збільшуємо
 кількість шляхів на 1. Якщо непарних чисел
 більше, то ми не можемо симетрично їх розставити
 тому неможливо створити паліндром, тому повертаєм 0
 */