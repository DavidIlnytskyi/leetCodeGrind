/*
 https://leetcode.com/problems/sum-of-subarray-minimums/description/?envType=daily-question&envId=2024-01-20
 */

#include <vector>
#include <iostream>
#include <stack>

using namespace std;
class Solution {
public:
    int sumSubarrayMins(vector<int> &arr) {

        int module = 1000000007;

        vector<int> left(arr.size());
        vector<int> right(arr.size());

        stack <int> stck;

        for(int idx = 0; idx < arr.size(); ++ idx){
            while(!stck.empty() && arr[idx] < arr[stck.top()]){
                stck.pop();
            }

            if(!stck.empty()){
                left[idx] = idx - stck.top();
            } else {
                left[idx] = idx + 1;
            }

            stck.push(idx);
        }

        while(!stck.empty()){
            stck.pop();
        }

        for(int idx = arr.size() - 1; idx >= 0; --idx){
            while(!stck.empty() && arr[idx] <= arr[stck.top()]){
                stck.pop();
            }
            if(!stck.empty()){
                right[idx] = stck.top() - idx;
            } else {
                right[idx] = arr.size() - idx;
            }
            stck.push(idx);
        }

        int result = 0;

        for(int idx = 0; idx < arr.size(); ++idx){

            result += (left[idx] * right[idx] * arr[idx])%module;

        }


        return result % module;
    }
};

int main(){

    vector<int> input = {1, 3, 2, 4, 1};

    cout << Solution().sumSubarrayMins(input);

    return 0;
}

/*
 Main idea:

 Суть завдання:
 Суму всім мінімумів серед всім можливих підпослідовностей.

 Для цього використовується наступний підхід:
 Створимо два масиви де для кожного елементу
 ми будемо зберігати відстань до елементу
 зліва, що є менший ніж поточний елемент, таке
 ж буде для правої сторони.
 До прикладу
 {1, 4, 3, 6, 7}
 Для 3 відстань до меншого елементу зліва буде 2
 До меншого елементу справа буде 3, тому що меншого
 елементу справа не існує

 Для того щоб імплементувати це в коді ми використовуєм
 стак.

 Для кожного елемента ми перевіряємо, чи цей елемент менший ніж
 попередній елемент в масиві, якщо так то ми видаляємо найвищий
 елемент зі стаку й перевіряємо з елементом з некст елементом в
 стаці. Цей підхід є дуже оптимальний, адже якщо попередній
 елемент був найменшим з всіх попередніх, і поточний елемент є
 меншим ніж він, то залишиться перевірити лише один елемент, і
 після цього стак буде пустий.
 Якщо стак пустий, то всі елементи перед нашим елементом більші
 ніж поточний елемент. Тобто довжина підпослідовності зліва це
 позиція елемента + 1(вона включає всі попередні елементи з
 нашим елементом включно). Якщо стак не пустий після циклу while
 то в нас є елемент, який є менший ніж поточний елемент, тому
 наш елемент вже не буде включати цей менший елемент у свої
 підпослідовності. Тому ми зазначаємо довжину лівої послідовності
 як індекс поточного - індекс меншого елемента
 {1, 4, 3, 2)
 Індекс двійки 3, індекс 1 - 0. Довжина послідовності 3 - 0 = 3

 Таке ж для довжини підпослідовності справа.

 Кількість всіх можливих підпослідовностей рахується
 за формулою довжина зліва * довжину справа
 Для цього випадку буде 2 * 3 = 6
 Далі додаємо до результату кількість послідовностей де
 елемент є мінімум * на елемент.

 */