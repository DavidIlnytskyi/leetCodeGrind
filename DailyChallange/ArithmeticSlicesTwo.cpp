/*
 https://leetcode.com/problems/arithmetic-slices-ii-subsequence/description/?envType=daily-question&envId=2024-01-07
 */
#include <vector>
#include <map>
#include <iostream>

using namespace std;


class Solution {
public:
    int numberOfArithmeticSlices(vector<int>& nums) {
        int vectorSize = nums.size();
        int difference;
        int result = 0;
        int temp;
        vector<map<int, int>> dp(vectorSize);

        for(int idx = 1; idx < vectorSize; ++idx){
            for(int j = 0; j < idx; ++j){
                temp = 0;
                difference = nums[idx] - nums[j];
                if(dp[j][difference] != 0){
                    temp = dp[j][difference];
                }

                dp[idx][difference] = temp + 1;
                result += temp;
            }
        }
        return result;
    }
};

int main(){
    vector<int> input = {2,4,6,8,10};
    cout << Solution().numberOfArithmeticSlices(input);
}

/*
 Main idea:

 Головна ідея така:
 Беремо idx від одного до n.
 Ми будемо порівнювати всі елементи, що були перед idx
 наступним чином. Дивимось на різницю між nums[idx] та
 nums[j], де j це один з індексів, що є перед idx.
 Дивимось на dp[j], чи вже зустрічались для dp[j]
 така різниця.
 Тобто, якщо в нас nums[idx] - nums[j] дорівнює 5,
 ми дивимось чи була в dp[j] така послідовність,
 що мала різницю 5 за допомогою dp[j][difference]
 Якщо такої послідовності не було, то там буде 0.
 Якщо була така послідовність, але в ній було лише
 два елементи, там буде 1(при першій зустрічі двох
 елементів ми додаємо туди 1). Якщо була така пос-
 лідовність і там було більше ніж 2 елементи, то
 там буде інше число. У чому суть, число яке там
 буде, це кількість послідовностей, яку принесе
 збільшення розміру на один.

 Пояснення:
 При першій зустрічі двох елементів, що можуть
 сформувати послідовність ми додамо туди 1.
 Наступного разу, коли ми знайдемо ще один
 елемент, що може доповнити нашу послідовність
 ми візьмемо цю одиничку й додамо його до
 результату. Справді, додавши цю одиничку до
 результату ми зазначим, що утворилась одна
 послідовність з трьох чисел. Крім цього,
 збільшимо значення на одиничку.
 Наступного разу як ми знайдемо елемент, що
 продовжить цю послідовність, там буде лежати 2,
 адже на попередньому кроці ми додали 1, і якщо
 ми додамо до результату 2, то це буде кількість
 новоутворених послідовностей за рахунок нового
 елементу.

 Чому так:
 1 2 -- 1
 1 2 3 { 1, 2, 3 } -- (result += 1, set 2)
 1 2 3 4 { 2, 3, 4 | 1, 2, 3, 4 } -- (result += 2, set 3)
 Тобто ми наперед зазначаємо, як зміниться
 кількість послідовностей при збільшенні
 послідовностей на одиницю, проте використовуємо
 це значення лише тоді, коли збільшуєм цю послідовність.
 */